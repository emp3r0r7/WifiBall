<!DOCTYPE html>
<html lang="en">
<head>
    <title>Real-Time 3D WiFi Data with Babylon.js</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100%; display: block; }
        #data-container {
            white-space: pre-wrap;
            font-family: monospace;
            display: none; /* Nasconde il JSON grezzo */
        }
        #tooltip {
            position: absolute;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            border-radius: 5px;
            pointer-events: none;
            display: none;
            z-index: 1000;
        }
        #header {
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: #f8f8f8;
            border-bottom: 1px solid #ccc;
        }
        #header h1 {
            margin: 0;
            font-size: 1.5rem;
        }
        #header .btn {
            margin-left: auto;
        }

    </style>
</head>

<body>
<div id="header" class="d-flex align-items-center">
    <h1>Real-Time WiFi Data in 3D</h1>
    <button id="toggle-sidebar" class="btn btn-primary ms-3">Show AP List</button>
</div>
<div id="data-container"></div>
<div id="tooltip"></div>

<div id="sidebar" style="display:none; position: absolute; right: 0; top: 0; width: 250px; height: 100%; background-color: #f8f8f8; border-left: 1px solid #ccc; overflow-y: auto;">
    <h3 class="p-3">Access Points</h3>
    <ul id="ap-list" style="list-style-type: none; padding: 0;">
    </ul>
</div>

<!-- Modale per mostrare i dettagli dell'AP -->
<div class="modal fade" id="apModal" tabindex="-1" aria-labelledby="apModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl"> <!-- Aggiunta la classe modal-xl -->
        <div class="modal-content" style="height: 80vh;"> <!-- Altezza della modale -->
            <div class="modal-header">
                <h5 class="modal-title" id="apModalLabel">AP Details</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="apDetailsForm" class="row">
                    <!-- Dettagli AP -->
                    <div class="col-md-6 mb-3">
                        <label for="apEssid" class="form-label">ESSID</label>
                        <input type="text" class="form-control" id="apEssid" readonly>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label for="apBssid" class="form-label">BSSID</label>
                        <input type="text" class="form-control" id="apBssid" readonly>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label for="apLastSeen" class="form-label">Last Seen</label>
                        <input type="text" class="form-control" id="apLastSeen" readonly>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label for="apChannel" class="form-label">Channel</label>
                        <input type="text" class="form-control" id="apChannel" readonly>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label for="apPrivacy" class="form-label">Privacy</label>
                        <input type="text" class="form-control" id="apPrivacy" readonly>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label for="apCipher" class="form-label">Cipher</label>
                        <input type="text" class="form-control" id="apCipher" readonly>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label for="apAuthentication" class="form-label">Authentication</label>
                        <input type="text" class="form-control" id="apAuthentication" readonly>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label for="apPower" class="form-label">Power</label>
                        <input type="text" class="form-control" id="apPower" readonly>
                    </div>
                    <h5>Associated Stations</h5>
                    <div style="max-height: 300px; overflow-y: auto;">
                        <table class="table table-striped">
                            <thead>
                            <tr>
                                <th>Station MAC</th>
                                <th>First Time Seen</th>
                                <th>Last Time Seen</th>
                                <th>Power</th>
                                <th>Packets</th>
                                <th>BSSID</th>
                                <th>Probed ESSIDs</th>
                            </tr>
                            </thead>
                            <tbody id="stationTableBody">
                            <!-- Righe delle stazioni associate verranno aggiunte qui dinamicamente -->
                            </tbody>
                        </table>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>



<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
<script src="https://cdn.babylonjs.com/materialsLibrary/babylon.gridMaterial.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.min.js"></script>

<script>

    let canvas, engine, scene, camera, ground;
    let referenceSphere, arrowMesh;
    let selectedSphere = null;
    let marker = null;

    const highPow = -55;
    const midPow =  -70;

    const spheres = {}; // Mappa per tenere traccia delle sfere esistenti

    function createTooltip() {
        const tooltip = document.getElementById('tooltip');
        tooltip.style.position = 'absolute';
        tooltip.style.padding = '5px';
        tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        tooltip.style.color = '#fff';
        tooltip.style.borderRadius = '5px';
        tooltip.style.pointerEvents = 'none';
        tooltip.style.display = 'none';
        document.body.appendChild(tooltip);
        return tooltip;
    }

    function init() {
        // Get the canvas element
        canvas = document.createElement("canvas");
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.display = 'block';
        document.body.appendChild(canvas);

        // Generate the Babylon.js engine and scene
        engine = new BABYLON.Engine(canvas, true);
        scene = new BABYLON.Scene(engine);

        // Create an ArcRotateCamera, and set its position to the center of the scene
        camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 4, 100, BABYLON.Vector3.Zero(), scene);
        camera.attachControl(canvas, true);
        camera.wheelDeltaPercentage = 0.01; // Imposta la sensibilità dello zoom

        // Enable panning and zooming
        camera.panningSensibility = 1000;
        camera.lowerRadiusLimit = 2; // Limite minimo di zoom

        // Add lights to the scene
        const light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
        light1.intensity = 0.7;

        const light2 = new BABYLON.DirectionalLight("light2", new BABYLON.Vector3(0, -1, 1), scene);
        light2.intensity = 0.5;

        // Set background color to sky blue
        scene.clearColor = new BABYLON.Color3(0.5, 0.8, 1);

        // Create ground plane with a grid material
        ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 1000, height: 1000}, scene);

        // Crea un materiale personalizzato per il piano con una griglia
        const gridMaterial = new BABYLON.GridMaterial("gridMaterial", scene);
        gridMaterial.gridRatio = 10; // Dimensione delle celle della griglia
        gridMaterial.majorUnitFrequency = 1; // Frequenza delle linee principali
        gridMaterial.minorUnitVisibility = 0.45; // Visibilità delle linee minori
        gridMaterial.gridOffset = new BABYLON.Vector3(0, 0, 0); // Spostamento della griglia
        gridMaterial.backFaceCulling = false; // Rende la griglia visibile su entrambi i lati
        gridMaterial.mainColor = new BABYLON.Color3(0.3, 0.3, 0.3); // Colore principale della griglia
        gridMaterial.lineColor = new BABYLON.Color3(1, 1, 1); // Colore delle linee della griglia
        gridMaterial.opacity = 0.5; // Imposta la trasparenza

        ground.material = gridMaterial;

        // Add a yellow reference sphere at the center
        referenceSphere = BABYLON.MeshBuilder.CreateSphere("referenceSphere", {diameter: 3}, scene);
        const referenceMaterial = new BABYLON.StandardMaterial("referenceMaterial", scene);
        referenceMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0); // Giallo
        referenceSphere.material = referenceMaterial;
        referenceSphere.position = new BABYLON.Vector3(0, 0, 0);

        // Create an arrow to represent the orientation (Yaw and Pitch) of the reference sphere
        const arrow = BABYLON.MeshBuilder.CreateCylinder("arrow", {diameterTop: 0, diameterBottom: 2, height: 10}, scene);

        const arrowMaterial = new BABYLON.StandardMaterial("arrowMaterial", scene);
        arrowMaterial.diffuseColor = new BABYLON.Color3(1, 0, 1); // magenta
        arrow.material = arrowMaterial

        arrow.parent = referenceSphere;
        arrow.position = new BABYLON.Vector3(0, 2.5, 0);
        arrow.rotation.x = 0; // Inizialmente parallela al piano
        arrowMesh = arrow;

        // Crea il segnalino sopra la sfera selezionata (una freccia o un altro oggetto)
        marker = BABYLON.MeshBuilder.CreateCylinder("marker", { diameterTop: 1, diameterBottom: 0, height: 3 }, scene);
        const markerMaterial = new BABYLON.StandardMaterial("markerMaterial", scene);
        markerMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0); // Verde chiaro
        marker.material = markerMaterial;
        marker.setEnabled(false); // Nascondi il segnalino fino a quando non è necessario

        // Start the render loop
        engine.runRenderLoop(() => {
            scene.render();
        });

        // Handle window resizing
        window.addEventListener("resize", () => {
            engine.resize();
        });

        // Create the tooltip
        createTooltip();
    }

    function calculateDistanceFromPower(power) {
        // Mappa la potenza (dBm) su una distanza. Più negativa è la potenza, maggiore è la distanza.
        const minDistance = 5;
        const maxDistance = 100;
        return BABYLON.Scalar.Lerp(maxDistance, minDistance, (power + 100) / 80); // Normalizza il valore tra 0 e 1
    }

    function calculatePositionFromGyroAndPower(gyroData, distance, arrowMesh) {
        const pitchRadians = arrowMesh.rotation.x + Math.PI / 2; // Pitch
        const yawRadians = arrowMesh.rotation.y; // Yaw

        // Invertiamo la direzione per proiettare dalla parte frontale della freccia
        const x = -distance * Math.cos(pitchRadians) * Math.sin(yawRadians);
        const y = distance * Math.sin(pitchRadians); // Muovere verso l'alto quando la freccia punta in alto
        const z = -distance * Math.cos(pitchRadians) * Math.cos(yawRadians);

        return new BABYLON.Vector3(x, y, z);
    }


    function updateReferenceSphereOrientation(gyroData) {
        // Normalizza l'angolo di yaw da -180 a 180 a un angolo tra 0 e 360 gradi
        let yaw = gyroData.axisZ;
        if (yaw < 0) {
            yaw = 360 + yaw;
        }

        // Converti in radianti e applica la rotazione
        const yawRadians = BABYLON.Tools.ToRadians(yaw);
        const pitchRadians = BABYLON.Tools.ToRadians(gyroData.axisX);

        // Applica le rotazioni
        arrowMesh.rotation.y = yawRadians; // Rotazione per Yaw (Z axis)

        // Inverti la rotazione per il pitch per correggere il comportamento
        arrowMesh.rotation.x = -pitchRadians - Math.PI / 2; // Inversione del pitch
    }

    function updateScene(frontEndData) {
        const readingMap = frontEndData.wifiDataMap;

        // Aggiorna l'orientamento della sfera di riferimento in base ai dati più recenti del giroscopio
        updateReferenceSphereOrientation(frontEndData.gyroData);

        for (const [bssid, dataReading] of Object.entries(readingMap)) {
            const power = dataReading.highestPower;
            const distance = calculateDistanceFromPower(power);

            // Passa l'orientamento corrente della freccia (arrowMesh) alla funzione di calcolo della posizione
            const position = calculatePositionFromGyroAndPower(dataReading.gyroData, distance, arrowMesh);

            // Verifica se la sfera esiste già e confronta la potenza
            if (spheres[bssid]) {
                if (power > spheres[bssid].currentPower) {
                    // Rimuovi la sfera esistente solo se la nuova potenza è maggiore
                    spheres[bssid].dispose();
                    delete spheres[bssid];
                } else {
                    // Se la potenza non è maggiore, salta al prossimo access point
                    continue;
                }
            }

            // Crea una nuova sfera
            const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2}, scene);
            const material = new BABYLON.StandardMaterial("material", scene);

            // Imposta il colore della sfera in base alla potenza del segnale
            if (power >= highPow) {
                material.diffuseColor = new BABYLON.Color3(0, 1, 0); // verde
            } else if (power >= midPow) {
                material.diffuseColor = new BABYLON.Color3(1, 1, 0); // Giallo
            } else {
                material.diffuseColor = new BABYLON.Color3(1, 0.5, 0); // Arancione
            }

            sphere.material = material;
            spheres[bssid] = sphere;
            spheres[bssid].currentPower = power;  // Memorizza la potenza corrente

            // Posiziona la nuova sfera basata sulla posizione della freccia
            sphere.position = position.add(referenceSphere.position);

            // Aggiungi ActionManager per gestire mouseover e mouseout
            sphere.actionManager = new BABYLON.ActionManager(scene);
            sphere.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPointerOverTrigger,
                function (evt) {
                    const tooltip = document.getElementById('tooltip');
                    tooltip.innerHTML = `
                    <strong>ESSID:</strong> ${dataReading.accessPoint.essid}<br>
                    <strong>BSSID:</strong> ${dataReading.accessPoint.bssid}<br>
                    <strong>Last Seen:</strong> ${dataReading.accessPoint.lastTimeSeen}<br>
                    <strong>Channel:</strong> ${dataReading.accessPoint.channel}<br>
                    <strong>Privacy:</strong> ${dataReading.accessPoint.privacy}<br>
                    <strong>Cipher:</strong> ${dataReading.accessPoint.cipher}<br>
                    <strong>Authentication:</strong> ${dataReading.accessPoint.authentication}<br>
                    <strong>Power:</strong> ${dataReading.accessPoint.power}<br>
                `;
                    tooltip.style.display = 'block';
                }
            ));

            sphere.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPointerOutTrigger,
                function (evt) {
                    const tooltip = document.getElementById('tooltip');
                    tooltip.style.display = 'none';
                }
            ));

            console.log(`Sfera disegnata - ESSID: ${dataReading.accessPoint.essid}, BSSID: ${dataReading.accessPoint.bssid}, Posizione: (${sphere.position.x}, ${sphere.position.y}, ${sphere.position.z})`);
        }
    }

    // Funzione per aggiornare la lista degli AP trovati nella sidebar
    function updateAPList(frontEndData) {
        const apList = document.getElementById('ap-list');
        apList.innerHTML = ''; // Pulisce la lista attuale

        // Converti l'oggetto wifiDataMap in un array e ordinalo per potenza del segnale (decrescente)
        const sortedEntries = Object.entries(frontEndData.wifiDataMap).sort(([, a], [, b]) => b.highestPower - a.highestPower);

        // Crea la lista ordinata
        for (const [bssid, dataReading] of sortedEntries) {
            const listItem = document.createElement('li');
            listItem.style.padding = '10px';
            listItem.style.cursor = 'pointer';

            // Controlla se ci sono associatedStations
            let itemName = `${dataReading.accessPoint.essid || 'Unknown'} (${bssid})`;
            if (Array.isArray(dataReading.associatedStations) && dataReading.associatedStations.length > 0) {
                itemName += ' *'; // Aggiungi un asterisco se ci sono stazioni associate
            }

            listItem.textContent = itemName;

            // Imposta il colore di sfondo della riga in base alla potenza del segnale
            if (dataReading.highestPower >= highPow) {
                listItem.style.backgroundColor = '#90EE90'; //verde chiaro
            } else if (dataReading.highestPower >= midPow) {
                listItem.style.backgroundColor = 'yellow';
            } else {
                listItem.style.backgroundColor = 'orange';
            }

            listItem.addEventListener('click', function () {
                // Popola i campi della modale con i dati dell'AP
                document.getElementById('apEssid').value = dataReading.accessPoint.essid || 'N/A';
                document.getElementById('apBssid').value = dataReading.accessPoint.bssid || 'N/A';
                document.getElementById('apLastSeen').value = dataReading.accessPoint.lastTimeSeen || 'N/A';
                document.getElementById('apChannel').value = dataReading.accessPoint.channel || 'N/A';
                document.getElementById('apPrivacy').value = dataReading.accessPoint.privacy || 'N/A';
                document.getElementById('apCipher').value = dataReading.accessPoint.cipher || 'N/A';
                document.getElementById('apAuthentication').value = dataReading.accessPoint.authentication || 'N/A';
                document.getElementById('apPower').value = dataReading.accessPoint.power || 'N/A';


                // Popola la tabella delle stazioni associate
                const stationTableBody = document.getElementById('stationTableBody');
                stationTableBody.innerHTML = ''; // Pulisce il contenuto precedente

                dataReading.associatedStations.forEach(station => {
                    const row = document.createElement('tr');

                    row.innerHTML = `
                        <td>${station.stationMac}</td>
                        <td>${station.firstTimeSeen}</td>
                        <td>${station.lastTimeSeen}</td>
                        <td>${station.power} dBm</td>
                        <td>${station.packets}</td>
                        <td>${station.bssid}</td>
                        <td>${station.probedEssids || 'N/A'}</td>
                    `;

                    stationTableBody.appendChild(row);
                });

                // Mostra la modale
                const apModal = new bootstrap.Modal(document.getElementById('apModal'));
                apModal.show();

                // Seleziona e evidenzia la sfera corrispondente
                selectSphere(bssid);
            });

            apList.appendChild(listItem);
        }
    }


    function positionMarker(sphere) {
        if (sphere) {
            // Posiziona il segnalino sopra la sfera
            marker.position = sphere.position.clone();
            marker.position.y += 3; // Sposta il segnalino sopra la sfera
            marker.setEnabled(true); // Rendi visibile il segnalino
        } else {
            marker.setEnabled(false); // Nascondi il segnalino se non c'è nessuna sfera selezionata
        }
    }

    function selectSphere(bssid) {
        // Trova la sfera corrispondente al BSSID selezionato
        const sphere = spheres[bssid];
        if (sphere) {
            // Posiziona il segnalino sopra la sfera selezionata
            positionMarker(sphere);
            selectedSphere = sphere;
        } else {
            // Se non c'è nessuna sfera corrispondente, disabilita il segnalino
            positionMarker(null);
        }
    }


    function connectWebSocket() {
        const socket = new WebSocket('ws://192.168.1.124:8011/data');

        socket.onmessage = function(event) {
            const dataContainer = document.getElementById('data-container');
            const frontEndData = JSON.parse(event.data);

            dataContainer.innerHTML = JSON.stringify(frontEndData, null, 2);
            updateScene(frontEndData);
            updateAPList(frontEndData); // Aggiorna la lista degli AP nella sidebar
        };

        socket.onclose = function(event) {
            console.log('WebSocket closed, reconnecting...');
            setTimeout(connectWebSocket, 5000);
        };

        socket.onerror = function(error) {
            console.error('WebSocket Error: ', error);
        };
    }

    window.onload = function () {
        init();
        connectWebSocket();
    };

    // Aggiungi un event listener globale per muovere il tooltip insieme al mouse
    document.addEventListener('mousemove', function (event) {
        const tooltip = document.getElementById('tooltip');
        if (tooltip.style.display === 'block') {
            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY + 10) + 'px';
        }
    });

    // Mostra/nasconde la sidebar
    document.getElementById('toggle-sidebar').addEventListener('click', function () {
        const sidebar = document.getElementById('sidebar');
        const toggleButton = document.getElementById('toggle-sidebar');

        if (sidebar.style.display === 'none') {
            sidebar.style.display = 'block';
            toggleButton.textContent = 'Hide AP List';
        } else {
            sidebar.style.display = 'none';
            toggleButton.textContent = 'Show AP List';
        }
    });

</script>
</body>
</html>
